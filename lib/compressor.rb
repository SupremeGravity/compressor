# encoding: utf-8
require 'fileutils'

unless defined?(Motion::Project::Config)
  raise "This file must be required within a RubyMotion project Rakefile."
end

module Motion::Project
  class Config
    def concat_files(opts={})
       concatenate_files!(extract_concatenated_files(Array(opts[:exclude])), opts[:parallel] || 4)
    end

    private

    def extract_concatenated_files(excluded=[])
      @files.flatten!
      concatenated_files = @files.select { |f| excluded.none? { |excluded_match| !!f.match(excluded_match) } }
      @dependencies = Dependency.new(@files - @exclude_from_detect_dependencies, @dependencies).run
      @files = @files - concatenated_files

      # Remove all concatenated files from the dependency hash
      @dependencies.each do |target, dependencies|
        if @files.include?(target)
          @dependencies[target] = dependencies - concatenated_files
        else
          @dependencies.delete(target)
        end
      end

      order_concatenated_files(concatenated_files)
    end

    def order_concatenated_files(concatenated_files)
      concatenated_files.map { |file| file_dependencies(file) }.flatten.uniq
    end

    def concatenate_files!(concat_files, parallel=4)
      group_number = 1
      previous_concat_path = nil

      concat_files.in_groups(parallel, false) do |group|
        concat_path = File.join(File.expand_path(@project_dir), "build", "app-concatenated-#{group_number}.rb")
        temp_concat_path = File.join(File.expand_path(@project_dir), "build", "app-concatenated-#{group_number}-temp.rb")
        Motion::Project::App.info "Concat", concat_path

        # Prep the concat path for writing
        Dir.mkdir(File.dirname(concat_path)) unless File.exist?(File.dirname(concat_path))
        File.new(concat_path, 'w') unless File.exist?(concat_path)

        # Concatenate this group of files
        File.open(temp_concat_path, 'a') do |concat|
          concat << "# File generated by 'Compressor' by Jamon Holmgren\n\n"
          concat << "# "
          group.each do |filename|
            concat << "# #{"=" * filename.length}\n"
            concat << "# #{filename}\n"
            concat << "# #{"=" * filename.length}\n"
            concat << File.read(filename)
            concat << "\n"
          end
        end

        if File.exist?(concat_path) && !FileUtils.cmp(temp_concat_path, concat_path)
          # Changed file, replace the original
          File.delete(concat_path)
          FileUtils.mv(temp_concat_path, concat_path)
        else
          # No change, throw it away
          File.delete(temp_concat_path)
        end

        # Add this concatenated file to the build files
        @files.unshift concat_path

        # Ensure that each file gets loaded in the right order
        if previous_concat_path
          files_dependencies concat_path => previous_concat_path
        end
        previous_concat_path = concat_path

        # Next group
        group_number += 1
      end
    end
  end
end

class Array
  # Splits or iterates over the array in +number+ of groups, padding any
  # remaining slots with +fill_with+ unless it is +false+.
  #
  #   %w(1 2 3 4 5 6 7 8 9 10).in_groups(3) {|group| p group}
  #   ["1", "2", "3", "4"]
  #   ["5", "6", "7", nil]
  #   ["8", "9", "10", nil]
  #
  #   %w(1 2 3 4 5 6 7 8 9 10).in_groups(3, '&nbsp;') {|group| p group}
  #   ["1", "2", "3", "4"]
  #   ["5", "6", "7", "&nbsp;"]
  #   ["8", "9", "10", "&nbsp;"]
  #
  #   %w(1 2 3 4 5 6 7).in_groups(3, false) {|group| p group}
  #   ["1", "2", "3"]
  #   ["4", "5"]
  #   ["6", "7"]
  def in_groups(number, fill_with = nil)
    # size / number gives minor group size;
    # size % number gives how many objects need extra accommodation;
    # each group hold either division or division + 1 items.
    division = size.div number
    modulo = size % number

    # create a new array avoiding dup
    groups = []
    start = 0

    number.times do |index|
      length = division + (modulo > 0 && modulo > index ? 1 : 0)
      groups << last_group = slice(start, length)
      last_group << fill_with if fill_with != false &&
        modulo > 0 && length == division
      start += length
    end

    if block_given?
      groups.each { |g| yield(g) }
    else
      groups
    end
  end
end

